<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom"><generator uri="http://jekyllrb.com" version="3.1.3">Jekyll</generator><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" /><updated>2016-07-05T00:07:15+08:00</updated><id>/</id><title>Oslo</title><subtitle>Web Developer from iCHEF</subtitle><entry><title>數值分析名詞紀錄</title><link href="/useful-command-or-function/" rel="alternate" type="text/html" title="數值分析名詞紀錄" /><published>2016-07-04T00:00:00+08:00</published><updated>2016-07-04T00:00:00+08:00</updated><id>/useful-command-or-function</id><content type="html" xml:base="/useful-command-or-function/">&lt;h1 id=&quot;story&quot;&gt;Story&lt;/h1&gt;
&lt;p&gt;最近發現，之前有些 google 過的東西，但是要再拿出來用的時候，突然忘記當初的關鍵字是下什麼了，又很緊急的要用，所以這次決定要把它記下來
(畢竟母語不是英文，常常會想不到對應的單字或者關鍵字)&lt;/p&gt;

&lt;h2 id=&quot;consecutive&quot;&gt;Consecutive&lt;/h2&gt;
&lt;p&gt;在數據分析很常用到的名詞，是來判斷 data 的連續性。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;原理是一個都是數字的 array，然後 duplicate 一份，原本的數值是 +1，兩個 array 再相減，大於 1 的就是不連續了。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;這點在 Numpy 上會很好作業，也只要一行就可以達成了&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def consecutive(data, step_size=1):
    &quot;&quot;&quot;
    :param data:
    :param int step_size: split size
    :rtype: np.array
    &quot;&quot;&quot;
    return np.array(np.split(np.array(data), np.where(np.diff(data) != step_size)[0] + 1))
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;np.diff(array)&lt;/code&gt; 會幫你計算 array 內，前一個與後一個的差值，回傳的結果是差值的 array&lt;/li&gt;
    &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;np.where(condition)&lt;/code&gt; 內是條件，找出條件為 True 的地方&lt;/li&gt;
    &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;np.split(array, split_index_list)&lt;/code&gt; 為切開 data， 後面的參數是要切開的 index 的 list&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;rolling-window&quot;&gt;Rolling Window&lt;/h2&gt;
&lt;p&gt;一樣在數值分析上很常碰到的名詞&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;我一連串的 Array 我需要計算移動平均(moving average)，就會需要用到，通常可以用來預測一些 pattern&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Example:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;[1, 2, 3, 4, 5]&lt;/code&gt; 的 array 想要變成 &lt;code class=&quot;highlighter-rouge&quot;&gt;[[1, 2], [2, 3], [3, 4], [4, 5]]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def rolling_window(data_series, window):
    &quot;&quot;&quot;
    :param np.array data_series:
    :param int window:
    :rtype: np.array
    &quot;&quot;&quot;
    shape = data_series.shape[:-1] + (data_series.shape[-1] - window + 1, window)
    strides = data_series.strides + (data_series.strides[-1],)
    return np.lib.stride_tricks.as_strided(data_series, shape=shape, strides=strides)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;shape 代表 array 的 (i, j)，此段主要是表示我切好後，array 應該是要長什麼模樣&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&quot;http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.strides.html&quot;&gt;numpy.ndarray.strides&lt;/a&gt;&lt;/p&gt;</content><author><name>oslo0322</name></author><summary>Story
最近發現，之前有些 google 過的東西，但是要再拿出來用的時候，突然忘記當初的關鍵字是下什麼了，又很緊急的要用，所以這次決定要把它記下來
(畢竟母語不是英文，常常會想不到對應的單字或者關鍵字)</summary></entry><entry><title>AWS 的 ELB 與 Nginx 的愛恨糾葛</title><link href="/aws-elb-nginx/" rel="alternate" type="text/html" title="AWS 的 ELB 與 Nginx 的愛恨糾葛" /><published>2016-06-12T00:00:00+08:00</published><updated>2016-06-12T00:00:00+08:00</updated><id>/aws-elb-nginx</id><content type="html" xml:base="/aws-elb-nginx/">&lt;h3 id=&quot;aws-elb--nginx&quot;&gt;當AWS ELB 碰到 Nginx，剛開始總是那麼地美好，但時間久了，總是會有些不是盡善盡美的地方…&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;ELB
    &lt;ul&gt;
      &lt;li&gt;我們先來談談 ELB 的 IP 機制，之所以 ELB 給你 DNS (註1) 是因為他每過數個小時之後會更換 IP，而且一個 DNS ，至少會有兩個以上的 IP，就是這樣才會使用好用的 DNS (DNS可以幹嘛？有空的話我再發文介紹吧～)&lt;/li&gt;
    &lt;/ul&gt;

    &lt;blockquote&gt;
      &lt;p&gt;這種機制不管是在 internal 或者 public ELB 上都是一樣的唷&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;Nginx
    &lt;ul&gt;
      &lt;li&gt;Nginx 在使用 pass_proxy，如果後面直接給予一個 DNS name 的話，他會先去 Query IP，然後把它儲存起來，而儲存的期限為…一萬年(其實是重新啟動就會更新了)，鑽石恆久遠，IP永流傳，不會自動地更新&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;
&lt;p&gt;聰明的客官們發現了這兩者的愛恨糾葛了嗎？&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Nginx 當你使用 pass_proxy 的時候，如果你後面直接使用 ELB 給你的 DNS (不管你後面有沒有把 DNS 做改寫)，過了數小時之後，你會發現很多 request 會開始轉發失敗而導致 502，因為 ELB 的 IP 變了…，不更新就無法轉送了&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;舉個有趣的例子，Nginx 好比一個木訥男，AWS ELB 好比一個時尚女人，木訥男要到時尚女的電話就死背著不忘，但時尚女三天兩頭就換個電話號碼，木訥男，大概也只有前幾天能連絡到時尚女吧(煙…&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;解法其實蠻簡單的，將轉向的網址設成變數，這樣每次 Nginx(木訥男) 的 &lt;a href=&quot;http://serverfault.com/questions/240476/how-to-force-nginx-to-resolve-dns-of-a-dynamic-hostname-everytime-when-doing-p&quot;&gt;Cache 只會儲存 5 分鐘&lt;/a&gt;(變成記憶力好比金魚的健忘男(誤..)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;resolver 10.0.0.0+2/16 # 可以參考 AWS DNS (註2);
set $upstream_endpoint http://xxxx.elb.amazonaws.com;
location / {
    proxy_pass $upstream_endpoint;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Nginx pass_roxy 裡面有提到&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;A server name, its port and the passed URI can also be specified using variables:

proxy_pass http://$host$uri;
or even like this:

proxy_pass $request;
In this case, the server name is searched among the described server groups, and, if not found, is determined using a resolver.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;註1. &lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%9F%9F%E5%90%8D%E7%B3%BB%E7%BB%9F&quot;&gt;Domain Name System&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;註2. &lt;a href=&quot;http://docs.aws.amazon.com/zh_cn/AmazonVPC/latest/UserGuide/VPC_DHCP_Options.html#AmazonDNS&quot;&gt;AWS DNS&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;參考 http://tenzer.dk/nginx-with-dynamic-upstreams/&lt;/p&gt;</content><author><name>oslo0322</name></author><summary>當AWS ELB 碰到 Nginx，剛開始總是那麼地美好，但時間久了，總是會有些不是盡善盡美的地方…</summary></entry><entry><title>在 AWS Lambda python 執行帶有 C module 的 libs</title><link href="/aws-lambda-with-c-module/" rel="alternate" type="text/html" title="在 AWS Lambda python 執行帶有 C module 的 libs" /><published>2016-06-11T00:00:00+08:00</published><updated>2016-06-11T00:00:00+08:00</updated><id>/aws-lambda-with-c-module</id><content type="html" xml:base="/aws-lambda-with-c-module/">&lt;p&gt;AWS Lambda 是一個很好用(邪惡?!)的東西，很多東西都可以用 Lambda 串起來，來達成event trigger 的目的，然而有個小小的缺點就是，很難開發跟 debug (CloudWatch)，所有執行的程式碼都放在 Lambda (可能實作上用docker?!)上。&lt;/p&gt;

&lt;p&gt;如果你是用 Mac OSX 系統開發的話，在一般情形下，只要照 &lt;a href=&quot;http://docs.aws.amazon.com/lambda/latest/dg/lambda-python-how-to-create-deployment-package.html&quot;&gt;AWS 官方文件&lt;/a&gt;上建議的方法，包成zip，就可以執行了，但要用含有 C module 的 libs，像是 Matplotlib, Pandas, Numpy, Scipy 等等的，就會遇到意想不到的事情。&lt;/p&gt;

&lt;p&gt;根據同事的解釋，雖然 Mac OSX 也算是 Unix 系統，但實際 compile C module 的方法還是有些微的不同，所以要在AWS Lambda 上執行上述的libs，網路上很多文章都建議開一台 EC2 先打包好(建議是zip)再丟到 S3 上，這樣執行起來就沒什麼問題了。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Tips：&lt;/p&gt;

  &lt;p&gt;如果想要 packaging/update 主要的程式的話，可以將上述包好的檔案(zip)檔案，下載回來再自行刪除，更新或者增加上去&lt;/p&gt;
&lt;/blockquote&gt;</content><author><name>oslo0322</name></author><summary>AWS Lambda 是一個很好用(邪惡?!)的東西，很多東西都可以用 Lambda 串起來，來達成event trigger 的目的，然而有個小小的缺點就是，很難開發跟 debug (CloudWatch)，所有執行的程式碼都放在 Lambda (可能實作上用docker?!)上。</summary></entry><entry><title>Bash Script 的一些簡單範例 Part 1</title><link href="/bash-script-simple-example/" rel="alternate" type="text/html" title="Bash Script 的一些簡單範例 Part 1" /><published>2016-06-07T00:00:00+08:00</published><updated>2016-06-07T00:00:00+08:00</updated><id>/bash-script-simple-example</id><content type="html" xml:base="/bash-script-simple-example/">&lt;h2 id=&quot;bash-script--unix--function&quot;&gt;Bash Script 是 Unix 系統內最好也最實用的內建語言，常常有些意想不到的 function&lt;/h2&gt;

&lt;h3 id=&quot;outline&quot;&gt;Outline&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;grep + awk&lt;/li&gt;
  &lt;li&gt;if else&lt;/li&gt;
  &lt;li&gt;find&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;grep--awk&quot;&gt;grep + awk&lt;/h4&gt;
&lt;p&gt;Example : &lt;code class=&quot;highlighter-rouge&quot;&gt;ls -al&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-rw-r--r--   1 oslo  staff   327 Jun  7 23:44 404.md
-rw-r--r--   1 oslo  staff     1 Jun  7 23:44 CNAME
-rw-r--r--   1 oslo  staff  1077 Jun  7 23:44 LICENSE
-rw-r--r--   1 oslo  staff  7939 Jun  7 23:44 README.md
-rw-r--r--   1 oslo  staff  2509 Jun  7 23:53 _config.yml
drwxr-xr-x   6 oslo  staff   204 Jun  7 23:44 _includes
drwxr-xr-x   5 oslo  staff   170 Jun  7 23:44 _layouts
drwxr-xr-x   6 oslo  staff   204 Jun  8 00:10 _posts
drwxr-xr-x   6 oslo  staff   204 Jun  7 23:44 _sass
drwxr-xr-x  14 oslo  staff   476 Jun  8 00:10 _site
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果說我想要找某些字串，例如 &lt;code class=&quot;highlighter-rouge&quot;&gt;drwxr-xr-x&lt;/code&gt;，可以利用 &lt;code class=&quot;highlighter-rouge&quot;&gt;grep&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Example : &lt;code class=&quot;highlighter-rouge&quot;&gt;ls -al | grep &quot;drwxr&quot;&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;drwxr-xr-x   6 oslo  staff   204 Jun  7 23:44 _includes
drwxr-xr-x   5 oslo  staff   170 Jun  7 23:44 _layouts
drwxr-xr-x   6 oslo  staff   204 Jun  8 00:10 _posts
drwxr-xr-x   6 oslo  staff   204 Jun  7 23:44 _sass
drwxr-xr-x  14 oslo  staff   476 Jun  8 00:10 _site
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;若我這時候還想要，某幾欄顯示的東西，例如第三欄這個 file 的 owner，就可以利用 &lt;code class=&quot;highlighter-rouge&quot;&gt;awk&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Example : &lt;code class=&quot;highlighter-rouge&quot;&gt;ls -al | grep &quot;drwxr&quot; | awk &#39;{print $2}&#39;&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;oslo
oslo
oslo
oslo
oslo
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;hr /&gt;

&lt;h4 id=&quot;if-else&quot;&gt;if else&lt;/h4&gt;

&lt;p&gt;判斷式，判斷是有分一行還是多行&lt;/p&gt;

&lt;p&gt;一行就是在&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;amp;&amp;amp;&lt;/code&gt; 之前為條件&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;amp;&amp;amp;&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;||&lt;/code&gt; 之間，是成立的時候要做啥&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;||&lt;/code&gt; 之後，是不成立的時候要做啥&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Example:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[[ $(ls -al | grep &quot;oslo&quot;) = &quot;&quot; ]] &amp;amp;&amp;amp; echo &quot;not found&quot; || echo &quot;found it&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;多行的範例&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;如果怕一行太多的話，可以最後面使用跳脫字元 &lt;code class=&quot;highlighter-rouge&quot;&gt;\&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;VARIABLE=$(ls -al | grep &quot;oslo&quot;);
if [[ &quot;$VARIABLE&quot; == &quot;&quot; ]];
    then
        echo &quot;not found&quot;
    else
        echo &quot;found it&quot;
fi

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;a href=&quot;http://stackoverflow.com/questions/13781216/bash-meaning-of-too-many-arguments-error-from-if-square-brackets&quot;&gt;參考&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&quot;find&quot;&gt;find&lt;/h4&gt;

&lt;p&gt;find 是我覺得真的非常好用的功能，可以找整個資料夾下的所有特定檔案，真的超方便的&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;find . -type f -name &quot;*.png&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;.&lt;/code&gt; 代表當前目錄&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-type f&lt;/code&gt; 搜尋的類型是檔案&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-name &quot;*.png&quot;&lt;/code&gt; 搜尋副檔名是 png&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;如果要刪掉檔案可以加上 -delete&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;最後提醒大家，如果想看說明文件的話可以用&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;man &amp;lt;你要的內建指令&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Example:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;man ls
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;離開的話按 q 即可&lt;/p&gt;
&lt;/blockquote&gt;</content><author><name>oslo0322</name></author><summary>Bash Script 是 Unix 系統內最好也最實用的內建語言，常常有些意想不到的 function</summary></entry><entry><title>如何使用 Machine-Learning 去處理一些非規則性的資料</title><link href="/using-ML-parsing-MOEA-pdf/" rel="alternate" type="text/html" title="如何使用 Machine-Learning 去處理一些非規則性的資料" /><published>2016-05-08T00:00:00+08:00</published><updated>2016-05-08T00:00:00+08:00</updated><id>/using-ML-parsing-MOEA-pdf</id><content type="html" xml:base="/using-ML-parsing-MOEA-pdf/">&lt;p&gt;在 iCHEF，我們會利用政府公開的資料做一些處理並加以利用，經濟部商業司(Ministry of Economic Affairs,R.O.C.) 以下簡稱 &lt;code class=&quot;highlighter-rouge&quot;&gt;MOEA&lt;/code&gt; 就是其中一個我們會利用的資料。&lt;/p&gt;

&lt;p&gt;MOEA 會在每個月10號釋出一些公司或者商業的登記資料，這些資料的格式是 &lt;code class=&quot;highlighter-rouge&quot;&gt;PDF&lt;/code&gt;，內容則有點像是 &lt;code class=&quot;highlighter-rouge&quot;&gt;EXCEL&lt;/code&gt;的樣式。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;分析資料&lt;/h2&gt;

&lt;h3 id=&quot;section-1&quot;&gt;工具&lt;/h3&gt;
&lt;p&gt;所謂工欲善其事，必先利其器，分析之前要先準備好工具&lt;/p&gt;

&lt;p&gt;而處理的工具，我們使用的是 &lt;code class=&quot;highlighter-rouge&quot;&gt;python&lt;/code&gt;，下面列出最主要的工具&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/euske/pdfminer&quot;&gt;PDFMiner&lt;/a&gt; 處理 PDF 的工具&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://scikit-learn.org/stable/&quot;&gt;scikit-learn&lt;/a&gt; ML工具&lt;/li&gt;
  &lt;li&gt;pandas/numpy/scipy python 數據分析的好用工具&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-2&quot;&gt;思考&lt;/h3&gt;
&lt;p&gt;謀定而後動，在開始處理資料之前，我們先來看看我們要處理的資料是什麼樣子&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/2016-5-8-using-ML-parsing-MOEA-pdf/1.png&quot; alt=&quot;pdf&quot; /&gt;
上圖是 PDF 內其中一頁，可以看到大致上跟 &lt;code class=&quot;highlighter-rouge&quot;&gt;EXCEL&lt;/code&gt; 一樣，除了最後面&lt;code class=&quot;highlighter-rouge&quot;&gt;營業項目說明&lt;/code&gt;除外，而通常我們的觀念會想要最後一欄，歸類在同一行的營業人，也就是下圖的概念。
&lt;img src=&quot;/img/2016-5-8-using-ML-parsing-MOEA-pdf/2.png&quot; alt=&quot;pdf&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;工具特性&lt;/h3&gt;
&lt;p&gt;PDFMiner 是將PDF的內容變成座標形式回傳的，以下圖為例&lt;/p&gt;

&lt;p&gt;『1』一個字就有一組四個&lt;code class=&quot;highlighter-rouge&quot;&gt;(x, y)&lt;/code&gt;座標，座標是由左下角開始，x往右變大，y往上變大
&lt;img src=&quot;/img/2016-5-8-using-ML-parsing-MOEA-pdf/3.png&quot; alt=&quot;pdf&quot; /&gt;&lt;/p&gt;

&lt;p&gt;字或者詞的判斷則是由下面的圖來解釋如何運作的
&lt;img src=&quot;/img/2016-5-8-using-ML-parsing-MOEA-pdf/4.png&quot; alt=&quot;pdf&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;M 表示兩個『字』之間的水平距離，如果大於某個值會判斷成兩個詞&lt;/li&gt;
  &lt;li&gt;W 表示兩個『詞』之間的水平距離，如果大於某個值會判斷成兩個詞&lt;/li&gt;
  &lt;li&gt;L 表示兩個『詞』之間的垂直距離，如果大於某個值會判斷成兩個斷行&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-4&quot;&gt;資料特性&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;/img/2016-5-8-using-ML-parsing-MOEA-pdf/2.png&quot; alt=&quot;pdf&quot; /&gt;
上圖可以很清楚地知道，欄位其實在某些地方有些不一樣(藍色線標明的地方)，像是名字因為兩個字置中而導致起始位置跟三個字的地方有些不一樣，大部分欄位都是靠左對齊，資本額的地方卻是靠右對齊，造成起始座標很難歸納出一個範圍。&lt;/p&gt;

&lt;p&gt;在分行的地方相對欄位來說，則是比較簡單的，可以藉由字詞 &lt;code class=&quot;highlighter-rouge&quot;&gt;y&lt;/code&gt; 的高度來判斷多少範圍內是屬於同一個營業人的情況&lt;/p&gt;

&lt;p&gt;例如：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;y的高度 (0, 484]   屬於最下面序號『9』的營業人&lt;/li&gt;
  &lt;li&gt;y的高度 (484, 515] 屬於最下面序號『8』的營業人&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-5&quot;&gt;解決問題&lt;/h2&gt;
&lt;p&gt;上述提到一個問題，欄位因為起始點不同，所以很難歸納出真正的範圍，這時候機器學習就派上用場了&lt;/p&gt;

&lt;p&gt;我們要解決的是分群的問題，分群常用的方法就屬於 &lt;code class=&quot;highlighter-rouge&quot;&gt;KNN&lt;/code&gt; 了，&lt;code class=&quot;highlighter-rouge&quot;&gt;KNN&lt;/code&gt; 是一種非監督式的機器學習演算法，簡單來說就是物以類聚的概念，我們利用未知座標 X 最鄰近的 N 個點來判斷 X 是屬於哪一個群組，以下圖為例
&lt;img src=&quot;http://bdewilde.github.io/assets/images/2012-10-26-knn-concept.png&quot; alt=&quot;pdf&quot; /&gt;
我們已經知道有『黃色』以及『紫色』兩組顏色，今天如果想要判斷『紅色』星星是屬於哪一個群組，KNN 中的 N 值，設定的不一樣，則會帶來不一樣的結果&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;如果 N 等於 3，半徑 3 的範圍內有兩個紫色一個黃色，那麼程式就會判斷有33.333%的機率是黃色，66.667%的機率是紫色&lt;/p&gt;

  &lt;p&gt;如果 N 等於 6，半徑 6 的範圍內有四個紫色兩個黃色，那麼程式就會判斷有66.667%的機率是黃色，33.333%的機率是紫色&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;我們利用這種物以類聚的概念來對我們的目的資料做 &lt;code class=&quot;highlighter-rouge&quot;&gt;MODEL&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;MODEL&lt;/code&gt;意思是將已經知道的值輸入進去給演算法，然後對新的值做預測，上述的『黃色』以及『紫色』的點就是所謂的 &lt;code class=&quot;highlighter-rouge&quot;&gt;MODEL&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;我們將三頁的資料做成 MODEL ，將網狀座標利用我們的 MODEL 做預測，不同的欄位用不同的顏色來表示，跑出N在不同的值下，所產生的結果如下&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/2016-5-8-using-ML-parsing-MOEA-pdf/KNN_1_STEP_3.png&quot; alt=&quot;pdf&quot; /&gt;
&lt;img src=&quot;/img/2016-5-8-using-ML-parsing-MOEA-pdf/KNN_2_STEP_3.png&quot; alt=&quot;pdf&quot; /&gt;
&lt;img src=&quot;/img/2016-5-8-using-ML-parsing-MOEA-pdf/KNN_4_STEP_3.png&quot; alt=&quot;pdf&quot; /&gt;
&lt;img src=&quot;/img/2016-5-8-using-ML-parsing-MOEA-pdf/KNN_5_STEP_3.png&quot; alt=&quot;pdf&quot; /&gt;
&lt;img src=&quot;/img/2016-5-8-using-ML-parsing-MOEA-pdf/KNN_10_STEP_3.png&quot; alt=&quot;pdf&quot; /&gt;&lt;/p&gt;

&lt;p&gt;這裡可以看出 N 在 1~2 之間的效果會比 4 以上效果來得好，我們可以利用畫出來的結果來決定使用的 N 值
然而這只有三頁的資料，就可以產生相當程度的分類，機器學習的前途果然不可限量啊！！&lt;/p&gt;</content><author><name>oslo0322</name></author><summary>在 iCHEF，我們會利用政府公開的資料做一些處理並加以利用，經濟部商業司(Ministry of Economic Affairs,R.O.C.) 以下簡稱 MOEA 就是其中一個我們會利用的資料。</summary></entry><entry><title>MySQL Indexing 的差別</title><link href="/MySQL-indexing-Story/" rel="alternate" type="text/html" title="MySQL Indexing 的差別" /><published>2016-04-25T00:00:00+08:00</published><updated>2016-04-25T00:00:00+08:00</updated><id>/MySQL-indexing-Story</id><content type="html" xml:base="/MySQL-indexing-Story/">&lt;p&gt;我們都知道 MySQL 的 index 很重要，會影響 query 的速度，設定 index 的時候，通常直覺會直接對 columns(fields) 直接下index。
這樣的做法在一般情形下當然是ok，速度也都還可以接受，但是當資料成長到千萬筆以上的時候，就開始出現問題了，MySQL 在index 的選擇並不會很聰明地將 index 合併在一起。&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;舉個例子&lt;/h3&gt;
&lt;blockquote&gt;
  &lt;p&gt;我有username 和 timestamp 的index，當 sql 語法下 where 的時候，MySQL 會根據你的資料量來選擇你適合的 index
假設以 username 撈出來會有200萬筆，timestamp 撈出來會有500萬筆，這時候 MySQL 會選擇使用 username 來做 index 的 key&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;問題來了，若符合 username 以及 timestamp 的資料可能才3萬筆，每次都要先撈200萬筆以後再去篩選嗎？這樣很慢吧！
所以 MySQL 又有一種 indexing 的方法是可以合併多個 columns 當 key 的，可以把 username 以及 timestamp 當做 key，這樣 MySQL 排序篩選的時候，會加快許多&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;附帶一提：Mongodb 的 indexing 也可以這麼做唷&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;每個 framework 的設定方法也不一樣，這裡用 Django 當作例子&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://docs.djangoproject.com/en/1.9/ref/models/options/#index-together&quot;&gt;Django Reference&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Meta:
  index_together = [
      [&quot;username&quot;, &quot;timestamp&quot;],
  ]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;這樣即可設定完成&lt;/p&gt;

&lt;h1 id=&quot;reference&quot;&gt;Reference&lt;/h1&gt;
&lt;p&gt;indexing 的方法有兩種，也有些差異，可以參考
&lt;a href=&quot;https://www.percona.com/blog/2014/01/03/multiple-column-index-vs-multiple-indexes-with-mysql-56/&quot;&gt;這裡&lt;/a&gt;&lt;/p&gt;</content><author><name>oslo0322</name></author><summary>我們都知道 MySQL 的 index 很重要，會影響 query 的速度，設定 index 的時候，通常直覺會直接對 columns(fields) 直接下index。
這樣的做法在一般情形下當然是ok，速度也都還可以接受，但是當資料成長到千萬筆以上的時候，就開始出現問題了，MySQL 在index 的選擇並不會很聰明地將 index 合併在一起。</summary></entry></feed>
