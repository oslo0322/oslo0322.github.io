---
layout: post
title: Interview Questions for Backend developer.
author: oslo0322
---

最近因為各種原因，短短幾個月內就一直在面試，就記錄一下最近碰到得面試題目吧。

# Process vs Thread
這大概是問最多的基本題吧，就連 [StackOverflow] 上面也是超多人在問的。
* [微軟提供的]
* [Others]

我覺得一開始可以這樣說：

每個 Process 都有提供需要的資源去執行程式，一個 Process 會有獨立的 process id、環境變數以及至少一個 Thread 來執行，當然，可以增加額外的 Tread。

> 意即每個 Process 處於不同的記憶體空間上，所以無法分享記憶體。

每個 Thread 則是在 Process 之下，可以被排程執行，所有的 Thread 共用相通的資源以及記憶體空間上，每個 Thread 有自己獨立的 Thread id 跟 local storage.

> 意即每個 Thread 處於相同的記憶體空間上，所以是分享記憶體的。

----

用日常生活的方式舉個例子的話，比較像是高速公路的概念。

國道一號跟國道三號就是不同的 Process，國道內的線道就是不同的 Thread，國道內的所有車輛(程式)共用全部的縣道(Address Space)，而當國道一號發生車禍導致塞車的時候，其他車輛就會因此受到影響，但是國道三號的車卻不受影響。

## Process vs Thread 筆記

### Apache
後來又看到 [mode_wsgi的這篇]，裡面提到了Apache提供了三種不同的Mode

||Multi-Process|Multi-Thread|
|-----|:-----:|-----|
|Prefork|Yes|No|
|Worker|Yes|Yes|
|Winnt|No|Yes|

----
Worker 文件也提到了 [Python GIL] 的問題，裡面說法是因為中間是由 mod_uswgi 做中介給Apache，所以 Thread 以及 Process 是由 Apache(C code)管理，而不是 Python，所以在Multi-Core CPU表現上會比較好。

我也好奇 Worker 是如何產生 Process/Thread 的，其實概念也蠻簡單的，就是先把Process 內的 Thread 塞滿，滿了之後再開 Child Process 依此類推。

### Nginx
[Nginx+uWSGI] 這篇看來，uWSGI則沒有處理 GIL 的問題，如果有碰到 I/O bound的問題，看來還是只能乖乖地關掉 thread 了(QQ)


[StackOverflow]: https://stackoverflow.com/questions/200469/what-is-the-difference-between-a-process-and-a-thread?page=1&tab=votes#tab-top

[微軟提供的]: https://msdn.microsoft.com/en-us/library/windows/desktop/ms681917(v=vs.85).aspx

[Others]: http://web.archive.org/web/20100807021758/http://kquest.co.cc/2010/03/program-process-task-thread

[mode_wsgi的這篇]:http://modwsgi.readthedocs.io/en/develop/user-guides/processes-and-threading.html

[Nginx+uWSGI]: https://www.reddit.com/r/Python/comments/4s40ge/understanding_uwsgi_threads_processes_and_gil/

[Python GIL]https://wiki.python.org/moin/GlobalInterpreterLock


# What's the different between HTTP methods POST and GET?

一開始的想法比較像是用 [REST](https://en.wikipedia.org/wiki/Representational_state_transfer) 的想法用 `Resource` 的角度去描述的，但後來對方問更深，就倒了...

回家後查了一下[Source](https://www.diffen.com/difference/GET-vs-POST-HTTP-Requests)，其實有很多是知道的，但當下沒想到，有點可惜，順便截取一些重點。

||GET| POST|
|-----|:-----:|-----|
|History 參數會被存|Yes|No|
|Bookmarked|Yes|No|
|參數(Parameters)|Yes|Yes|
|Data Type 限制|ASCII|無限制，Binary也可以，所以可以傳檔案|
|Data length 限制|2048個字元上限|無|
|**Cached**|Yes|No|

# What is REST and RESTful?

REST 是 `Representational State Transfer` 的縮寫，是一種傳輸資料的『風格』不是一種『標準』，利用 HTTP methods(GET/POST/PUT/PATCH/DELETE) 等等不同的操作來對伺服器的資源做管理。
具有幾個特點：

* 以資源為基礎
* 統一的介面
* 無狀態(Stateless)
* Client-server architecture
* Cacheability
* Layered system

而具有 `REST` 風格的API，就是 RESTful API。

# How CSRF token be generated?
上次被問到如何解決 CSRF 攻擊的問題，我提到了利用 CSRF token 可以解決，而對方問到了更深入，那你知道 CSRF token 是如何產生的嗎？
當初猜是類似用 One-Time password 到方式，伺服器端有存密鑰，然後依照時間產生一組時間內有效的 token 放在 Database 內。

後來查到這裡有解釋如何產生的[Source](https://stackoverflow.com/questions/8655817/csrf-protection-do-we-have-to-generate-a-token-for-every-form)

裡面提到，通常是用 per-session 的方式產生的，隨機產生一組 token 放入 session 內，session id 跟 token 會傳給 client，如果回來的 session id 與 token 是一樣的，就是有效的。

更甚者，如果要更安全，可以每次產生表單或者每個 request的時候都產生一次，但會把整個設計變得相當複雜。

在[這裡][1]提到

#### Synchronizer (CSRF) Tokens
* Any state changing operation requires a secure random token (e.g., CSRF token) to prevent CSRF attacks
* Characteristics of a CSRF Token
* Unique per user ***session***
* Large random value
* Generated by a cryptographically secure random number generator
* The CSRF token is added as a hidden field for forms or within the URL if the state changing operation occurs via a GET
* The server rejects the requested action if the CSRF token fails validation

[1]: https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)_Prevention_Cheat_Sheet#General_Recommendation:_Synchronizer_Token_Pattern